function [y,e]= LMS_algorithm_check(step_size, tap_weights, number_of_Symbols, u, v, N)
    y = zeros(1,number_of_Symbols);                 % Output row vector defined
    e = zeros(1, number_of_Symbols);                % Row vector representing error defined
    w = zeros(number_of_Symbols,tap_weights);       % Matrix for filter weights defined where each 
                                                    % row is designated for each ieration
    w(tap_weights, (tap_weights + 1)/2)= 1;         % tap weights initialised    
%   err_wrt_step = randn(length(step_size_LMS), number_of_Symbols);
    
    % Desired response is N sampled delayed version of channel's input where N =7
    
    d = circshift(u, N);                            % Delayed version of u generated by padding zeros 
    d(1:N)=0;                                       % in the beginning
    
        
%         for i=1:length(step_size_LMS)
            for j = tap_weights:number_of_Symbols 
                range = j:-1 : j-tap_weights+1;
                y(j) = w(j,:)*v(range)';                  % Output generated (1*11)*(11*1)
                e(j) = d(j)-y(j);                        % Error calculation
                w(j+1,:) = w(j,:) + step_size*v(range)*e(j);       % Weight adpatation with each iteration
            end
end